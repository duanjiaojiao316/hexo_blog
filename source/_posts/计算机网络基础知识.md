---
title: 计算机网络基础知识
categories:
  - 计算机网络
translate_title: basic-knowledge-of-computer-network
date: 2020-03-09 21:56:09
---
# 计算机网络

## 网络层

### ICMP网际控制报文协议

ICMP报文是IP层数据报文的数据，加上IP头部组成IP报文。

#### 种类

##### ICMP差错报告报文

1. 终点不可达：当路由器或者主机不能交付数据报时，就向源点发送终点不可达报文。
2. 时间超过：当路由器收到生存时间为0的数据报时，丢失数据报，向源点发送时间超过报文。当终点在预定时间段内不能收到数据报的全部内容，就会丢弃已收到的数据报，向源点发送时间超过报文。
3. 参数问题：当路由器或者主机在收到数据报时发现首部的有些字段的值不正确时，丢弃该数据报，就会向源点发送参数问题报文。
4. 改变路由（重定向）：路由器把改变路由报文发送给主机，让主机直到下次发送数据报更好的路由路径。

##### ICMP询问报文

1. 回送请求和回答：主机或者路由器向一个特定的目的主机发送访问，收到此报文的主机必须给源主机或者路由器发送ICMP回送回答报文。这种询问报文用于测试目的站点是否可达。
2. 时间戳请求和回答：请求某台主机或者路由器回答当前的时间和日期。可用于时钟同步和时间测量。

**PING**是ICMP的一个重要的应用，测试两台主机的连通性。

### 路由选择协议

#### 内部网关协议RIP

一种分布式的基于距离向量的路由选择协议，路由表维护从自己到其他目的网络的距离（距离向量，跳数）。RIP允许一条路径最多只能包含15个路由器，距离为16时不可达，RIP只适用于小型互联网。

RIP不能在两个网络之间同时使用多条路径，RIP选择具有最少路由器的路径，哪怕存在一个具有较多路由器但是高速的

RIP协议特点：

1. 仅与相邻的路由交换信息
2. 交换信息为全部的路由表
3. 按固定时间间隔交换路由信息

实现简单，开销小，好消息传的快，坏消息传的慢。

算法：

相邻路由器发来的RIP报文，对所有项目进行修改，把下一跳的路由都改成相邻路由器，距离都加1。

修改后的报文项目与将要更新的路由表进行对比：

1. 原来的路由表中没有该目的网络，就加入该项目。
2. 若下一跳的路由器是相邻路由器，则更新下一跳距离。
3. 如果存在目标网络，但是下一跳路由不同，选择其中较小的。

如果三分钟后没有收到相邻路由表的更新信息，那么这个路由不可达，设置距离为16。

#### 内部网关协议PSPF

使用迪杰斯特拉算法（Dijkstra）——最短路径优先

协议不收厂商控制——开发

分布式链路状态协议

OSPF特点：

1. 向本自治系统的所有路由器发送信息——洪泛法，而RIP只向相邻的路由器发送信息。
2. 发送信息是该路由与相邻路由的所有路由器的链路状态。链路状态是与哪些路由相邻以及该链路的度量（费用、距离、时延、带宽）。
3. 只有链路状态发生变化路由器采用洪泛法发送此信息。

在OSPF中，没有路由器都知道全网的链路状态。

为了使OSPF用于更大的网络，将自治系统再划分为区域，划分区域，将洪泛法交换链路信息的范围局限于一个区域，减少整个网络的通信量。

#### 外部网关协议BGP

配置BGP每一个自治系统都需要一个BGP发言人，为边界路由器发言人之间通过共享网络连接在一起。通过TCP发送，交换网络可达性信息。

## 传输层

IP层通信的两端是两台主机，运输层通信的两端是主机之间的进程。

### 运输层的复用与分用

复用是指发送方不同的应用程序都可以使用同一个运输层协议传送数据。

分用是指接收方的传输层剥去报文的首部后能够把这些数据正确交付到目的应用进程。

### 协议端口号

TCP/IP的运输层用16位端口号标记一个端口。端口号只具有本地意义。

服务器端使用的

熟知端口号（系统端口号）0-1023

| 应用程序   | FTP  | TELNET | SMTP | DNS  | TFTP | HTTP | SNMP | SNMP(trap) | HTTPS |
| ---------- | ---- | ------ | ---- | ---- | ---- | ---- | ---- | ---------- | ----- |
| 熟知端口号 | 21   | 23     | 25   | 53   | 69   | 80   | 161  | 162        | 443   |

登记端口号1024-49151

客户端使用的端口号49152-65535

### 用户数据报协议UDP

#### 特点

1.  无连接

2.  尽最大努力交付

3. 面向报文

   发送方的UDP对应用层交下来的报文添加首部后就下交付IP层。对应用层下交下来的报文不合并不拆分。一次发送一个报文。

4. 没有拥塞控制

5. 首部开销小

6. 支持一对一一对多多对一多对多的交互通信

由于UDP之间的通信要用到端口号，但是无连接的因此不需要使用套接字来建立连接。相比TCP就需要在两个套接字之间建立连接。

#### 计算检验和

方法与IP检验相似，但是IP数据报的检验和只检验IP数据报的首部，UDP检验和把首部和数据部分一起检验。

##### 步骤：

1. 先把全零放入检验和字段
2. 把伪首部和用户数据报看成许多16位的字串联用户数据报的数据不是偶数字节（也就是不是16位）不是则要填入全零。
3. 二进制反码求和
4. 求和结果写入检验和字段
5. UDP数据报发送。接收方二进制反码求这16位的和。结果为1无差错。

### 传输控制协议TCP

1. 面向连接的传输层协议
2. 每条连接只能连接两个端点
3. 可靠交付
4. 全双工通信
5. 面向字节流

#### 停止等待协议ARQ

每发送一个分组就会停止发送，等待对方的确认，在收到确认之后在发送下一个分组。发送方在一段时间后没有收到确认就会重传前面发送过的分组，超时重传。所以发送方都会暂时保存已发送分组的副本，只有在收到确认之后才会清楚副本。

发送方和接收方发送分组都需要进行编号。

确认丢失，接收方发送的确认分组丢失，发送方重传，接收方重复收到分组：

1. 丢弃这个分组，不向上层交付
2. 向发送方重新发送确认分组

确认迟到，接收方发送的确认迟到，发送方收到重复的确认，发送方丢弃确认，不做任何处理。

#### 连续的ARQ协议

发送方维持发送窗口，发送方每发送一个分组，窗口就会向前移动一个分组的位置，接收方采用**累计确认**的方法，不必对接收的每个分组逐个发送确认，而是对按照次序到达的最后一个分组的发送确认。表明这个分组之前的所有分组全部到达。

##### 累积确认的优点缺点：

- 容易实现，确认丢失也不必重传
- 不能向发送方反应接收方已经正确收到的所有分组的信息

TCP报文首部

- **ACK **当ACK=1确认号字段才有效。

- **SYN** 当SYN=1 ACK=0这是一个连接请求报文段，若对方同意建立连接，在响应的报文段SYN=1 ACK =1。

  所以当SYN=1表明这是一个连接请求或者链接接受报文。

- **FIN** 当FIN=1表明此报文段的发送方的数据发送完毕，并请求释放运输连接。

- **窗口** 发送本报文段的一方的接收窗口。窗口值为了告诉发送方目前接收方允许发送的数据量。

# 计算机网络——DNS系统

## DNS起源

由于要访问网络上的计算机，就需要直到其IP地址，但是IP地址是一段没有规律的数组，很难记忆，一旦一个计算机改变其IP地址就需要告知所有人。

为了方便记忆人们为计算机起名字，建立计算机名字到地址的一个映射关系。我们访问计算机的名字，剩下的名字到地址的转换过程则由计算机自动完成。 

早期，名字到地址的转换过程十分简单。每台计算机保存一个<font color="red">hosts文件</font>，里面列出所有计算机名字和对应的IP地址，然后定期从一个维护此文件的站点更新里面的记录。当我们访问某个计算机名字时，先在hosts文件找到对应的IP，然后就可以建立连接。 

 ![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgLnPFibxYxSFFpXPWNocZ4VpHEHOz2Is88QML1xsSibsqJZ65mMIVia0e5Oh7ETnfCBq4AsXAG7mDV7A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

早期的ARPANET就是这样做的，但是随着网络规模的扩大，这种方法渐渐吃不消了。主要有以下三个原因：

1. hosts文件变得非常大；
2. 主机名字会冲突；
3. 集中的维护站点会不堪重负（需要给几百万机器提供hosts文件，想想就可怕）。

为了解决上面的问题，1983年Paul Mockapetris提出了域名系统（ `DNS`, Domain Name System)，这是一种`层次的、基于域`的命名方案，并且用`一个分布式数据库系统加以实现`。当我们需要访问一个域名（其实就是前面说的计算机的名字）时，应用程序会向DNS服务器发起一个DNS请求，DNS服务器返回该域名对应的IP地址。通过下面三种手段解决了上面的问题：

1. 用户计算机上并没有存储所有的名字到IP的映射，这样避免了hosts文件过于庞大（现在各操作系统中hosts文件默认都是空的）。
2. 规定了域名的命名规则，保证主机名字不会重复。
3. DNS服务器不再是单一的一台机器，而是一个层次的、合理组织的服务器集群。

这样访问一个域名的过程可以简化为下图：

 ![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgLnPFibxYxSFFpXPWNocZ4VpicVDHaxIWrbX8wUzBicJiaPj79yuicia6GibXZkVjZur3hrr4yXpZOCwm7iag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

## DNS协议

那么如何具体实现这个所谓的域名系统呢，要知道管理一个超大型并且不断变化的域名到IP的映射集合可不是一个简单的事，况且还要去应付成千上万的DNS查询请求。人们最终想出了一套不错的协议，规定如何来实现这个系统，下面我们一起来看看吧。

首先我们需要制定一套命名规则，防止域名出现重复。DNS关于域名的规则和我们生活中的快递系统类似，使用层次的地址结构。快递系统中要给某人邮寄物品，地址可能是这样：中国、广东省、广州市、番禺区、中山西路12号 XXX。而一个域名看起来则是这样的groups.google.com（为什么不是com.google.groups？我猜可能和老外写地址的习惯有关）。

对于Internet来说，域名层次结构的顶级（相当于国际快递地址中的国家部分）由ICANN（互联网名称与数字地址分配机构）负责管理。目前，已经有超过250个顶级域名，每个顶级域名可以进一步划为一些子域（二级域名），这些子域可被再次划分（三级域名），依此类推。所有这些域名可以组织成一棵树，如下图所示:

 ![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgLnPFibxYxSFFpXPWNocZ4VptBzxaVXc4VVlzqeF2icyVsHCUsGD9QxQibibbptqZ6cu6mbrY49MYicI4g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

DNS设计之初是用来建立域名到IP地址的映射，理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可。这里的记录一般叫作域名资源记录，它是一个五元组，可以用以下格式表示：



```
Domain_name Time_to_live Class Type Value
```

其中：

**Domain_name**：指出这条记录适用于哪个域名；

**Time_to_live**：用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间（后面会讲到缓存机制）；

**Class**：一般总是IN；

**Type**：记录的类型；

**Value**：记录的值，如果是A记录，则value是一个IPv4地址。

我们看到域名资源记录有一个Type字段，用来表明记录的类型。这是为什么呢？因为对于一个域名来说，通常并非只记录其IP地址，还可能需要一些其他种类的记录，一些常见的记录类型如下：



![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgLnPFibxYxSFFpXPWNocZ4VpTgWrR6ichJ8qG6icfr1JfuLmK1usPwVtPal2HgPjyFokgVxiahmlCJDZg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

我们知道**不能只用一台域名服务器来响应所有的DNS查询**，因为没有一台机器能够给全球的用户提供查询服务，计算能力、存储、带宽都不允许。只能合理组织一个**域名服务器集群**，使他们协同工作，共同提供域名解析服务。接下来首先要面对的一个问题是如何合理地将所有的域名资源记录存储到不同的域名服务器上。

前面说过域名的名字空间可以组织为一棵树，这里我们可以**进一步将其划分为不重叠的区域（DNS zone）**，针对上图的域名空间，一种可能的域名划分如下图：

**![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgLnPFibxYxSFFpXPWNocZ4VpVZlgJy21z0p8ic1h0ib0ghibLCgssiagbkJrVPXhX8Uh2ffLthIoPbENtg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)**



然后将每个区域与多个域名服务器（其中一个是master，其他slave服务器则用来提供数据备份、加快解析速度、保证服务可用性）关联起来，称这些域名服务器为该区域的`权威域名服务器(Authoritative Name Servers )`，它保存两类域名资源记录：

**1**：该区域内所有域名的域名资源记录。

**2**：父区域和子区域的域名服务器对应的域名资源记录（主要是NS记录）。

这样，所有的域名资源记录都保存在多个域名服务器中，并且所有的域名服务器也组成了一个层次的索引结构，便于我们后面进行域名解析。下面以一个简化的域名空间为例子，说明域名资源记录是如何保存在域名服务器中的，如下图:

 ![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgLnPFibxYxSFFpXPWNocZ4VpHIlicNgbcTNzhqWqSfW7TiaGPyeficXMmpD1WR8nvPHmf3wDZmO9iaUd6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

图中域名空间划分为A, B, C, D, E, F, G七个DNS区域，每个DNS区域都有多个权威域名服务器，这些域名服务器里面保存了许多域名解析记录。对于上图的NDS区域E来说，它的权威域名服务器里面保存的记录如图中表格所示。

仔细观察上图你可能会发现区域A、B并没有父区域，他们之间并没有一条路径连在一起。这将导致一个很麻烦的问题，那就是区域A的权威域名服务器可能根本不知道区域B的存在。认识到这一点后，你可能会想出一个很自然的解决方案，就是在A中记录B域名服务器的地址，同时在B中记录A的，这样它们两个就联系起来了。但是考虑到我们有超过250个顶级域名，这样做并不是很恰当。

而我们使用的域名系统则采用了一种更加聪明的方法，那就是引入**根域名服务器**，**它保存了所有顶级区域的权威域名服务器记录。**现在通过根域名服务器，我们可以找到所有的顶级区域的权威域名服务器，然后就可以往下一级一级找下去了。下图为全球根域名服务器的分布图，可以在这里找到。

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgLnPFibxYxSFFpXPWNocZ4VpHicpOALwQoVyxUUiaO3dKvyVMUkLyibqpCrDZFWhMejIFnAzOIZicQFKAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

现在为止，我们的权威域名服务器和根域名服务器其实组成了一个树，**树根为根域名服务器，下面每个节点都是一个区域的权威域名服务器**，对于图a中各个DNS区域的权威域名服务器，它们组成了下面这棵树（实际中，一个权威域名服务器可能保存有多个DNS区域的记录，因此权威域名服务器之间的联系并不构成一棵树。这部分的详细内容可以参考RFC 1034: 4. NAME SERVERS。下面为了容易理解，将其简化为一棵树）：

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgLnPFibxYxSFFpXPWNocZ4Vpcyj1JKZzKEceQAOYNkXtfxaEWXvX7mEXC9GOBQS3cdoib7mC1fMB1wg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

​																							`域名服务器树`

## 域名解析

我们已经有了一个域名服务器集群，该集群合理地保存了域名空间和域名资源记录的对应关系。现在我们要做的就是发送一个DNS请求给域名服务器，然后坐等它返回正确的域名资源记录，这个过程叫作域名解析。

严格来说，域名解析的过程最早要追溯到建立网络连接。因为每当连接上网络之后，计算机会自动获得一个默认的DNS服务器，当然你也可以用自己信任的DNS服务器，比如8.8.8.8（DNS服务器也有信任不信任之分，是的，实践篇会讲到），我们把这个域名服务器也叫作`本地域名服务器`。接下来当我们需要知道一个域名对应的资源记录时，会向本地域名服务器发起请求，如果该域名恰好在本地域名服务器所辖属的域名区域（DNS zone）内，那么可以直接返回记录。

如果在本地域名服务器没有发现该域名的资源记录，就需要在整个域名空间搜索该域名。而整个域名空间的资源记录存储在一个分层的、树状联系的一系列域名服务器上，所以本地域名服务器首先要从根域名服务器开始往下搜索。这里有一个问题就是**本地域名服务器如何找到根域名服务器在哪里呢？**其实**域名服务器启动的时候，就会加载一个配置文件，里面保存了根域名服务器的NS记录**（要知道根域名服务器地址一般非常稳定，不会轻易改变，并且数量很少，所以这个配置文件会很小）。找到根域名服务器之后，就可以一级一级地往下查找啦。

仍然以我们的图a为例，现在假设区域E内的某个用户想访问math.sysu.edu.cn，那么请求的过程如下：

![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==) ![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgLnPFibxYxSFFpXPWNocZ4Vpn3mJIEtPMTG0nBvuSguCdhnxoWCr3pFQFNqocdHSSsTRkD2Gp8PTaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

​																			域名解析过程

用语言简单描述如下：

**1**：用户：喂，**本地域名服务器**，告诉我math.sysu.edu.cn的地址；

**2**：本地域名服务器：哎呀，我不知道啊，不在我的辖区，容我去问问老大哥吧。**root老大**，能告诉我math.sysu.edu.cn的地址吗；

**3**：根域名服务器：忙着呢，你去问B（.cn）；

**4**：本地域名服务器：喂，B，告诉我math.sysu.edu.cn的地址；

**5**：B：你去问D（.edu.cn）；

**6**：本地域名服务器：喂，D，告诉我math.sysu.edu.cn的地址；

**7**：D：你去问F（sysu.edu.cn）；

**8**：本地域名服务器：喂，F，告诉我math.sysu.edu.cn的地址；

**9**：F：容老衲看看，哎呀，找到了，是X.X.X.X；

**10**：本地域名服务器：踏破铁鞋终于找到啦，喂用户，出来啊，我找到了，是X.X.X.X

## 缓存机制

现在整个域名系统已经可以为我们提供域名解析服务了，当我们输入域名，计算机发送DNS请求，然后DNS服务器返回给我们解析的结果，一切看起来很完美。然而是不是可以更完美呢？

回顾一下平时浏览网站的情况，我们会发现两个比较有意思的结论：

**1**：80%的时间我们都在看那些20%的网站，这就是大名鼎鼎的**80/20 Rule**；

**2**：我们会在一个网站的不同网页之间跳转，也就是不断地访问同一个域名，类似程序访问的局部性原理。

这两条结论很容易让我们联想到缓存机制。如果我们**将已经访问过的那些域名的解析结果缓存在自己的计算机上，那么下次访问的时候可以直接读取结果，不用再次重复DNS查询过程，给自己和域名服务器都节省了麻烦。**

当然，这样做的一个前提是要缓存的解析结果不会频繁更改，也就是说我十分钟后解析一个域名的结果和现在解析的结果是一样的。对大多数域名来说，这都是一个不争的事实。但是难免有一些“善变”的域名，他们可能会频繁更改自己的解析结果。为了使缓存机制适应这两类情况，我们在域名资源记录里面添加一个`Time_ti_live`字段，表明这条记录最多可以缓存多久。对于那些“稳如泰山”的域名，给一个比较大的值，而那些“朝三暮四”的域名，则可以给定一个小的值。

我们既然可以在本机利用缓存，那么可不可以在域名服务器上也利用缓存机制呢，答案当然是可以的。因为对于域名服务器来说，上面的两条有意思的结论仍然有效。所以，域名服务器可以将那些访问过的域名资源记录缓存，用户再次发起请求时，可以直接返回缓存结果，不用去迭代或者递归解析。

## 域名注册、绑定

首先明确一点，每个人都可以去注册域名。大多数时候我们希望去注册一个顶级域名（比如selfboot.cn, google.com等），那些二级域名毕竟不够好记（比如github托管博客的域名：username.github.io）。有的顶级域名（比如.tk域名）提供免费的一年域名试用，不过绝大多时候还是要为自己的域名付费的（一般是按年付费，也不是很贵）。

要想去注册域名，首先得找到域名注册商，国内的比较著名的有DNSpod等，国外的有godaddy等。相信注册过域名的人都知道绝大多数我们能想到的自己喜欢的域名都已名花有主了，只剩那些不是那么惹人关注的域名供我们选择。所以，注册域名时，发现自己每想到一个域名都显示被人注册后，那太正常不过了，说明你的品味比较正常。

这里一点个人建议，选中一个域名后不要轻易去改了，因为换域名成本挺高的（我猜现在就算给淘宝一千万，它也不会换另成一个域名吧）。所以，最好不要去用免费的域名，因为指不定啥时候就不让你用了。你应该相信这么一个观点：天下没有免费的午餐。拓展一下就是，掏钱买服务，心里踏实。

接下来你可能会希望将自己的站点或者博客挂在自己选中的域名下，这其实很简单，只需要找到一个提供域名解析的服务商，然后填写相应的域名解析记录。大多时候，你注册域名的服务商都会免费提供域名解析服务。

现实中，大部分人可能会拥有个人博客，以前我们都是依赖一个博客平台（如CSDN），或者是买一台VPS托管自己的博客。不过自从Github推出了Blog服务，好多程序员都转而将博客托管在上面。Github Blog支持绑定个人域名，并提供了详细的绑定文档：Adding a CNAME file to your repository。假设你的博客已经可以通过 username.github.io 访问，接下来只需要用 CNAME 告诉Github你的博客绑定了哪个域名（比如说是selfboot.cn），然后在域名解析商那里添加解析记录即可，下图是我个人博客在DNSpod的解析记录：

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJPROpenqRIUKib5HAwDLjJBLzkicZPubuUOj0dd0tns6R6MicqT3eVuPmR5Niabcm4AXDc8iaiaHwYJlCw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

现在当我们访问 selfboot.cn 时，DNSpod就会将请求解析到 Github 提供的 IP 地址上。之后 Github 上面的博客托管服务器在所有用户的 CNAME 记录中，找到本次请求的域名对应的博客项目地址，比如说是 xuelangZF.github.io，然后返回博客内容。

## 域名解析

我们都知道一个域名的解析过程中，可能会有多台域名服务器给我们帮助，那么我们怎么能看到这些背后的功臣呢？先介绍两个常用的关于DNS的命令。

dig(Domain Information Groper), 是 UNIX/BSD 系统自带的 DNS 诊断工具，使用十分灵活、方便。

查询 selfboot.cn 的A记录，并返回简短的结果：

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJPROpenqRIUKib5HAwDLjJBSeTk5PNx8WicrJOjrSaSa7CfX9XM9Q6W8yJOlEAyXp2pH6PA1l5xdDA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

用 dig 还可以查询某一 ip 对应的域名，如下：

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJPROpenqRIUKib5HAwDLjJBrxDkwqLUn825ZOxbaL7oGeibw3aSoibPJcqQib1fiaETibE9sctxo7ibFb6Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这里返回的是pages.github.com，因为当你访问博客地址 selfboot.cn 时，其实是Github的pages 服务器（域名是：pages.github.com）在后台返回该博客内容的（根据 CNAME 确定返回哪个博客）。

nslookup 也是一个 DNS 诊断工具，几乎所有平台都自带该工具，使用也很简答，可以用 man 查询手册。

## 解析路径查询

接下来用 dig 命令查看从根域名到指定域名中间可能经过的所有域名服务器，使用 `+trace` 选项即可。

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJPROpenqRIUKib5HAwDLjJBfdEC6SnbVVeibUeS9B2Bs3BrwNfdBl8I11cJWlIMeP8TunDfRWLul2Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到最开始是13台顶级域名服务器的NS记录（中间省去一些记录减少行数，方便观察更清楚），接下来是顶级域名 cn. 的权威域名服务器（省略一些输出），然后是 selfboot.cn 的 NS 记录，即 DNSpod 的两条 NS 记录，最后从 f1g1ns2.dnspod.net 找到 selfboot.cn 的 A 记录。

seveas 提供了一个可视化的路径查询工具：dnsgraph，可以在线绘制跟域名到指定域名的所有可能路径。

当然，实际查询过程中，大多时候我们在本地缓存或者本地域名服务器缓存就能直接找到需要的域名记录，不需要每次都向根域名服务器发起请求，然后重复迭代或者递归查询过程。

## DNS缺陷

域名系统设计的很理想很美好，然而仍有一些小的瑕疵，可能会给我们带来些许困扰，首先，有些域名对注册人没有限制，而另外一些域名则对谁可以得到一个域名空间中名字有限制。比如pro域名是分配给合适的专业人员，但问题是谁才是专业的呢？显然医生、工程师是专业人员，但理发师、管道工呢？

此外，域名也可以被倒卖。黄牛们会批量注册大量域名（据说com域名下几乎每一个普通词都被人尝试注册了域名），然后转身就以高价转卖给那些对该域名感兴趣的人，这就是所谓的域名抢注。所以，现在你想注册一个符合自己网站特点的域名是很难的。

这个问题其实还不算严重，更要命的是下面两个问题。

## DNS劫持

我们知道一个域名服务器对其区域内的用户解析请求负责，但是并没有一个机制去监督它有没有真地负责。也就是说域名服务器的权力并没有被关在笼子里，所以它既可以认真地“为人民服务”，也可以**指鹿为马**。于是有些流氓的域名服务器故意更改一些域名的解析结果，将用户引向一个错误的目标地址。这就叫作 DNS 劫持，主要用来阻止用户访问某些特定的网站，或者是将用户引导到广告页面。

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJPROpenqRIUKib5HAwDLjJBYLG7qoNRpIdRQcayHV2ibpv4IAMSuraPBqRxhUxNcDJajayGqpHHqGg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

下面验证下我所用的域名服务器有没有干这种坏事，只需要一条简单的命令即可：

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJPROpenqRIUKib5HAwDLjJBEqlLue0icpEXrKmPmsUXXDyjNHxm4lA0gDoibyMqIeu6LTTft40H3rAw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

我的DNS服务器地址为10.8.4.4，他告诉我google.com的地址是120.196.0.5，我才不信呢。于是用`whois 120.196.0.5`一看，果真不是Google的地址。针对DNS劫持，我们可以简单地更换域名服务器，比较靠谱的一个是Google提供的8.8.8.8。下面用 8.8.8.8 来解析一下 www.google.com 就能看到正确的地址了。

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJPROpenqRIUKib5HAwDLjJBxGKPmQdhRx0h6CyUCsQibWmgnwnC4bPpMaoIUW5lSZXaqdKTVzibctfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



## DNS欺骗

DNS 劫持通过简单的切换域名服务器就可以绕过，不过一旦你遇上了 `DNS 欺骗`，就无法简单地绕过了。下面我们用不同的域名服务器来查看 fb 的 IP 地址，结果都返回了同一个地址，看起来好像是真的一样，不过也仅仅是看起来而已。

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJPROpenqRIUKib5HAwDLjJBejyTncDB8aDnNAlvLFcsrJ4ZBHCfeo5tjiaPPC5A0TplOLibZSNtWXSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这个地址并不是 fb 的服务器地址（可以在 ViewDNS 查询所有域名**真实的**域名资源记录，ViewDNS是个很好玩的网站，里面有许多有意思的工具）。其实我Google了一下这个地址，竟然发现了一篇不错的译文，看来这个地址早在 2011 年就有了特殊的含义（英文原文是相关阅读第一个）。

DNS 欺骗简单来说就是用一个假的 DNS 应答来欺骗用户计算机，让其相信这个假的地址，并且抛弃真正的 DNS 应答。在一台主机发出 DNS 请求后，它就开始等待应答，如果此时有一个看起来正确（拥有和DNS请求一样的序列号）的应答包，它就会信以为真，并且丢弃稍晚一点到达的应答。

![img](https://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJPROpenqRIUKib5HAwDLjJBqUnibZh6kgXJiaEcKOwJaZ2LrdBO05UeTRqqDqKzXOHAngkzQmnTtkmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

实施 DNS 欺骗的关键在于伪造一个有特定序列号的应答包，并且让其抢先一步到达发起请求的主机。这对于个人来说还有点难度，但是对于拥有骨干网节点的组织来说，实在是易如反掌，所以这么多网站都已沦陷。不过使用网上流传的那些 hosts文件，就可以在本机缓存许多网站的ip地址，进而可以和部分网站通信。但是通过hosts文件并不能完全 Cross the Great FireWall，因为人家还有很多其他手段。

## 反向DNS

反向DNS是已经知道IP的前提下，查询域名。反向DNS也是采用分层查询方式，对于一个IP地址(比如106.10.170.118)，依次查询**in-addr.arpa节点**(如果是IPv6，则为**ip6.arpa节点**)，106节点，10节点，170节点，并在该节点获得106.10.170.118对应的域名。

# 计算机网络——SSL协议

## 非对称加密

对称加密的原理相对比较直观，而非对称加密听起来就有些神奇。经过非对称加密产生的密文，就算知道加密的方法，也无法获知原文。实现了非对称加密的经典算法是RSA算法。它来自于数论与计算机计数的奇妙结合。我们从下面的情境中体验一下RSA算法的妙处。

我是潜伏在龙凤大酒楼的卧底。想让下面信息以加密的方式发到总部：A CHEF HIDE A BED，厨子藏起来了一张床！这是如此的重要，需要立即通知总部。千万重要的是，不能让反革命的厨子知道。

第一步是转码，也就是将英文转换成某个对应的数字。这个对应很容易建立，比如：



![img](http://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJTpvIEVicXyj8jy3XK8wsqCk8vQjoWPZ1R75VbPJ7KcMe4iaRHLXNib5dbm07NIK2JrwqzmVpkDlXlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

将上面的信息转码，获得下面的数字序列：

![img](http://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJTpvIEVicXyj8jy3XK8wsqCUnicCS1121Z913HedWLJzmT8N8XpuGx4tkS119NgfUlmmwI8vbWBWGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



这串数字完全没有什么秘密可言。厨子发现了这串数字之后，很容易根据数字顺序，对应字母表猜出来。

为了和狡猾的厨子斗智斗勇，我们需要对这串数字进一步加密。使用总部发给我们的锁，两个数字：3和10。我们分为两步处理。第一步是求乘方。第一个数字是3，也就是说，总部指示我们，求上面数字串的3次方：

![img](http://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJTpvIEVicXyj8jy3XK8wsqC1LwXpf6niaERCXUqpX7OKNxr2xzkcH7icDzQ5jHGV87N4q8JjfcIhdrg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

将这串数字发回总部。中途被厨子偷看到，但一时不能了解其中的意思。如果还是像刚才一样对应字母表的话，信息是：AGBEFBIDEAHED，这串字母完全不包含正常的单词。

信息到了总部。总部开始用神奇的钥匙来解读。这个钥匙是3。在这个简单的粒子里，钥匙不小心和之前锁中的一个数字相同。但这只是巧合。复杂的情况下很容易让锁和钥匙不同。解锁过程也是两步。第一步求钥匙次的乘方，即3次方。第二步求它们除以10（锁之一）的余数。

![img](http://mmbiz.qpic.cn/mmbiz_png/FWANMMXDrgJTpvIEVicXyj8jy3XK8wsqCbcDl1zXNNzdTEHWl32sypjAwFeEmkyctlo97cLDgr8ZRbOqgsqkAwg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这正是我们发送的信息。对应字母表，总部可以立即知道原来的信息。就此，我们简单的体验了RSA算法的使用过程。鉴于这里篇幅有限，这里不再详细解释RSA算法的原理。

## SSL协议

可以看到，非对称加密从安全性上要强过对称加密。但天下没有免费的午餐。非对称加密的运算成本同样也比较高。为了兼顾效率和安全，SSL协议同时使用了非对称和对称加密。它用对称加密算法来加密信息本身。但对于安全性比较脆弱的对称加密密钥，则采用非对称加密的方式来传输。

SSL协议分为客户端和服务器端。通信的核心步骤很简单：

（1）双方利用明文通信的方式确立使用的加密算法。

（2）利用非对称算法通信，交换一个密钥。

（3）该密钥用于对称加密算法，加密接下来的通信正文。

可以看到，SSL协议的关键是用一个非常安全的方式来交换一个对称密钥。交换的过程会比上面的描述更加复杂一些。

（1）客户发起请求时，除了说明自己支持的非对称加密算法，还会附加一个客户端随机数(client random)。

（2）服务器回复请求时，会确定非对称加密算法和哈希函数，并附上公钥。此外，服务器端还会在此次通信中附加一个服务器端随机数(server random)。

（3）客户端会产生第三个随机数(Premaster secret)，然后利用服务器确定的非对称加密算法和公钥来加密这个随机数，再发送给服务器端。

（4）客户端用自己的私钥解密第三个随机数。

（5）这样，客户端和服务器端都知道了三个随机数。双方各自用商量好的哈希函数从三个随机数获得对称加密的密钥。

即使明文通信的时候，某些信息被窃听，但第三步的非对称加密通信部分可以保证窃听者无法完整的获得三个随机数。这样，窃听者还是不知道对称加密的密钥是什么。这样，对称加密的密钥就在一个安全的环境中获得了。为了进一步安全，服务器的公钥会包含在一个数字证书中发送给客户。这样，客户还可以通过数字证书来验证服务器的身份，以免服务器本身出现问题。 

今年来使用越来越广泛的HTTPS协议就是在SSL/TLS协议的基础上进行通信。HTTP协议在通信过程中要经过多重路由，很容易被窃听。经过SSL协议加密的信息就算被窃听，也只能被通信目的地的人解读，从而保证了信息的安全。所以，如果所访问的网站没有使用HTTPS协议，那么在输入银行账号和密码之类的敏感信息时，就要三思而后行了。



## 一、SSL协议的握手过程

开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。

握手阶段分成五步。

> 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
>
> 第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
>
> 第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。
>
> 第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。
>
> 第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。 

![bg2014092003](D:\面试\SSL协议原理图\bg2014092003.png)

## 二、私钥的作用

握手阶段有三点需要注意。

> （1）生成对话密钥一共需要三个随机数。
>
> （2）握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。
>
> （3）服务器公钥放在服务器的数字证书之中。

从上面第二点可知，整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。这就是CloudFlare能够提供Keyless服务的根本原因。

某些客户（比如银行）想要使用外部CDN，加快自家网站的访问速度，但是出于安全考虑，不能把私钥交给CDN服务商。这时，完全可以把私钥留在自家服务器，只用来解密对话密钥，其他步骤都让CDN服务商去完成。

![bg2014092005](D:\面试\SSL协议原理图\bg2014092005.png)

上图中，银行的服务器只参与第四步，后面的对话都不再会用到私钥了。

## 三、DH算法的握手阶段

整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。

虽然理论上，只要服务器的公钥足够长（比如2048位），那么Premaster secret可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的[RSA算法](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)，改为 [Diffie-Hellman算法](http://zh.wikipedia.org/wiki/迪菲－赫尔曼密钥交换)（简称DH算法）。

采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。

![bg2014092007](D:\面试\SSL协议原理图\bg2014092007.png)

上图中，第三步和第四步由传递Premaster secret变成了传递DH算法所需的参数，然后双方各自算出Premaster secret。这样就提高了安全性。

## 四、session的恢复

握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。

这时有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。

session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。

![bg2014092009](D:\面试\SSL协议原理图\bg2014092009.png)

上图中，客户端给出session ID，服务器确认该编号存在，双方就不再进行握手阶段剩余的步骤，而直接用已有的对话密钥进行加密通信。

session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。

![bg2014092011](D:\面试\SSL协议原理图\bg2014092011.png)

上图中，客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。