---
title: 阅读redis设计与实现笔记
categories:
  - 后端
tags:
  - redis
  - 阅读笔记
translate_title: read-redis-design-and-implementation-notes
date: 2020-02-23 20:57:04
---
# redis设计与实现笔记

## 第一部分 数据结构与对象

### 1.简单动态字符串

### 2.链表

### 3.字典

### 4.跳跃表

### 5.整数集合

### 6.压缩列表

### 7.对象

## 第二部分 单机数据库的实现

### 9.数据库

### 10.RDB持久化

### 11.AOF持久化

### 12.事件

### 13.客户端

### 14.服务器端

## 第三部分 多机数据库的实现

### 15.复制

### 16.Sential

### 17.集群

## 第四部分 独立功能的实现

### 18.发布与订阅

### 19.事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

`Redis` 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。

#### **为什么`Redis`不支持回滚**

`Redis`命令在事务中可能会执行失败，但是`Redis`事务不会回滚，而是继续会执行余下的命令。如果您有一个关系型数据库的知识，这对您来说可能会感到奇怪，因为关系型数据在这种情况下都是会回滚的。

`Redis`这样做，主要是因为:只有当发生语法错误(这个问题在命令队列时无法检测到)了，`Redis`命令才会执行失败, 或对keys赋予了一个类型错误的数据：这意味着这些都是程序性错误，这类错误在开发的过程中就能够发现并解决掉，几乎不会出现在生产环境。由于不需要回滚，这使得`Redis`内部更加简单，而且运行速度更快。

### 20.lua脚本

### 21.排序

### 22.二进制数组

- `SETBIT`为二进制数组指定偏移上的二进制位设置值
- `GETBIT`获取二进制数组中指定偏移的二进制位的值
- `BITCOUNT`计算二进制数组中以1为值的二进制位有多少个
- `BITOP`可以对多个二进制数组进行按位与、按位或、按位异或、取反等操作。

字符串对象表示位数组，因为字符串对象使用SDS数据结构是二进制安全的，可以直接使用SDS数据结构来保存维数组。

SDS数据结构中buf数组中的顺序和平时书写顺序相反。

### 23.慢查询日志

记录执行时间超过给定时长的命令请求，用户通过慢日志查询的日志来监视和优化查询速度。

- `slowlog-log-slower-than` 指定执行时间超过多少微妙的命令请求会被记录在日志之中。设置为0，所有的请求都会记录在日志中。
- `slowlog-log-max-len`指定服务器最多可以保存多少命令请求。如果设置为5，服务器最多只能存储5个命令请求，以先进先出的方式保存，如果指令数量已经是`slowlog-log-max-len`，删除最旧的命令请求添加新的命令请求。

`SLOWLOG GET`命令查看服务器存储的慢查询日志。

![image-20191124211640527](D:\面试\springbootimages\image-20191124211640527.png)

```c
typedef struct slowlogEntry{
	long long id;//唯一标识符
    time_t time;//命令执行时的时间，Unix时间戳
    long long duration;//执行命令消耗的时间
    robj **argv;//命令与命令参数
    int argc;//命令与命令参数的个数
}
```

`SLOWLOG_RESET`清除慢查询日志中的所有日志。

添加新的日志

1. 检查是否超过`slowlog-log-slower-than` ，如果查过创建一个新的日志添加在`slowlog`链表的表头。
2. 判断链表的长度是否查过`slowlog-log-max-len`，如果查过就从链表的表尾删除一个。

### 24.监视器

通过MONITOR 命令客户端将自己变为一个监视器，实时接收打印服务器端处理命令请求的信息。当一个客户端向服务器发送一个请求，服务器除了处理命令请求还会将所有的信息发送给所有的监视器。

`list *monitor` 记录打开REDIS_MONITOR标志的客户端，也就是将自己变成监视器的客户端。

服务器端调用`replicationFeedMonitors`该函数来实现发送信息给所有监视器。

## 第五部分 面试题

### 1.`Redis` 具体有 6 种内存淘汰策略：

#### 内存淘汰策略

| 策略              | 描述                                                     |
| ----------------- | -------------------------------------------------------- |
| `volatile-lru`    | 从已设置过期时间的数据集中挑选**最近最少使用**的数据淘汰 |
| `volatile-ttl`    | 从已设置过期时间的数据集中挑选**更早过期**的数据淘汰     |
| `volatile-random` | 从已设置过期时间的数据集中**任意选择**数据淘汰           |
| `allkeys-lru`     | 从所有数据集中挑选**最近最少使用**的数据淘汰             |
| `allkeys-random`  | 从所有数据集中**任意选择**数据进行淘汰                   |
| `noeviction`      | 当内存不足以容纳新写入数据时，**新写入操作会报错**       |

#### redis 过期策略

redis 过期策略是：**定期删除+惰性删除**。

所谓**定期删除**，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。

假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的**灾难**。实际上 redis 是每隔 100ms **随机抽取**一些 key 来检查和删除的。

但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你**获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。**

> 获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。

但是实际上这还是有问题的，如果定期删除**漏掉了很多过期 key**，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？

答案是：**走内存淘汰机制**。

### 2.项目中缓存是如何使用的？

这个，需要结合自己项目的业务来。

#### 为什么要用缓存？

用缓存，主要有两个用途：**高性能**、**高并发**。

##### 高性能

假设这么个场景，你有个操作，一个请求过来，吭哧吭哧你各种乱七八糟操作 mysql，半天查出来一个结果，耗时 600ms。但是这个结果可能接下来几个小时都不会变了，或者变了也可以不用立即反馈给用户。那么此时咋办？

缓存啊，折腾 600ms 查出来的结果，扔缓存里，一个 key 对应一个 value，下次再有人查，别走 mysql 折腾 600ms 了，直接从缓存里，通过一个 key 查出来一个 value，2ms 搞定。性能提升 300 倍。

就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。

##### 高并发

mysql 这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql 单机支撑到 `2000QPS` 也开始容易报警了。

所以要是你有个系统，高峰期一秒钟过来的请求有 1万，那一个 mysql 单机绝对会死掉。你这个时候就只能上缓存，把很多数据放缓存，别放 mysql。缓存功能简单，说白了就是 `key-value` 式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发 so easy。单机承载并发量是 mysql 单机的几十倍。

> 缓存是走内存的，内存天然就支撑高并发。

### 3.如何保证缓存与数据库的双写一致性？

一般来说，如果允许缓存和数据库偶尔有不一致的情况（要求不严格的情况下）最好不要做这个方案，即：**读请求和写请求串行化**，串到一个**内存队列**里去。

串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，**用比正常情况下多几倍的机器去支撑线上的一个请求**。

#### Cache Aside Pattern

最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。

#### **为什么是删除缓存，而不是更新缓存？**

1. 缓存的数据不是直接从数据库取出，而是经过复杂的计算
2. 更新缓存的代价（频繁的数据库修改，频繁的缓存更新，但是却很少访问）只有用到的时候再重新计算放在缓存。

原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。

比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。

另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于**比较复杂的缓存数据计算的场景**，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，**这个缓存到底会不会被频繁访问到？**

举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有**大量的冷数据**。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。**用到缓存才去算缓存。**

其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。

#### 不一致问题解决方法

1.先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。

> 解决思路：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。

2.数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，**查到了修改前的旧数据**，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了...

在高并发下缓存出现这个问题：

> 更新数据的时候，根据**数据的唯一标识**，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 `jvm` 内部队列中。
>
> 一个队列对应一个工作线程，每个工作线程**串行**拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。

#### 了解什么是 redis 的雪崩、穿透和击穿？redis 崩溃之后会怎么样？系统该如何应对这种情况？如何处理 redis 的穿透？

##### 缓存雪崩

对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。

> - 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。
> - 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
> - 事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。

限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？**走降级**！可以返回一些默认的值，或者友情提示，或者空白的值。

好处：

- 数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。
- 只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。
- 只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。

##### 缓存穿透

对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是**黑客发出的恶意攻击**。

黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。

举个例子：数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“**视缓存于无物**”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。

解决方式：

> 每次系统 A 从数据库中只要没查到，就写一个**空值**到缓存里去，比如 `set -999 UNKNOWN`。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据

##### 缓存击穿

缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。

解决方式：

> 可以将热点数据设置为永远不过期；
>
> 基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。

### 4.redis 和 memcached 有啥区别？

#### redis 支持复杂的数据结构

redis 相比 memcached 来说，拥有[更多的数据结构](https://github.com/javazhiyin/advanced-java/blob/master/docs/high-concurrency/redis-data-types.md)，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作， redis 会是不错的选择。

#### redis 原生支持集群模式

在 redis3.x 版本中，便能支持 cluster 模式，而 memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。

#### 性能对比

由于 redis 只使用**单核**，而 memcached 可以使用**多核**，所以平均每一个核上 redis 在存储小数据时比 memcached 性能更高。而在 100k 以上的数据中，memcached 性能要高于 redis。虽然 redis 最近也在存储大数据的性能上进行优化，但是比起 memcached，还是稍有逊色。



### 5.redis 都有哪些数据类型？分别在哪些场景下使用比较合适？

除非是面试官感觉看你简历，是工作 3 年以内的比较初级的同学，可能对技术没有很深入的研究，面试官才会问这类问题。否则，在宝贵的面试时间里，面试官实在不想多问。

其实问这个问题，主要有两个原因：

- 看看你到底有没有全面的了解 redis 有哪些功能，一般怎么来用，啥场景用什么，就怕你别就会最简单的 KV 操作；
- 看看你在实际项目里都怎么玩儿过 redis。

要是你回答的不好，没说出几种数据类型，也没说什么场景，你完了，面试官对你印象肯定不好，觉得你平时就是做个简单的 set 和 get。

#### 面试题剖析

redis 主要有以下几种数据类型：

- string
- hash
- list
- set
- sorted set

##### string

这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存。

```
set college szu
```

##### hash

这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是**这个对象没嵌套其他的对象**）给缓存在 redis 里，然后每次读写缓存的时候，可以就操作 hash 里的**某个字段**。

```
hset person name bingo
hset person age 20
hset person id 1
hget person name
person = {
    "name": "bingo",
    "age": 20,
    "id": 1
}
```

##### list

list 是有序列表

**比如可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。**

**比如可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 list 实现分页查询，这个是很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。**

```
# 0开始位置，-1结束位置，结束位置为-1时，表示列表的最后一个位置，即查看所有。
lrange mylist 0 -1
```

比如可以搞个简单的消息队列，从 list 头怼进去，从 list 尾巴那里弄出来。

```
lpush mylist 1
lpush mylist 2
lpush mylist 3 4 5

# 1
rpop mylist
```

##### set

set 是无序集合，自动去重。

直接基于 set 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 jvm 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于 redis 进行全局的 set 去重。

**可以基于 set 玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？**

把两个大 V 的粉丝都放在两个 set 中，对两个 set 做交集。

```
#-------操作一个set-------
# 添加元素
sadd mySet 1

# 查看全部元素
smembers mySet

# 判断是否包含某个值
sismember mySet 3

# 删除某个/些元素
srem mySet 1
srem mySet 2 4

# 查看元素个数
scard mySet

# 随机删除一个元素
spop mySet

#-------操作多个set-------
# 将一个set的元素移动到另外一个set
smove yourSet mySet 2

# 求两set的交集
sinter yourSet mySet

# 求两set的并集
sunion yourSet mySet

# 求在yourSet中而不在mySet中的元素
sdiff yourSet mySet
```

##### sorted set

sorted set 是排序的 set，**去重但可以排序，写进去的时候给一个分数，自动根据分数排序。**

```
zadd board 85 zhangsan
zadd board 72 lisi
zadd board 96 wangwu
zadd board 63 zhaoliu

# 获取排名前三的用户（默认是升序，所以需要 rev 改为降序）
zrevrange board 0 3

# 获取某用户的排名
zrank board zhaoliu
```